---
layout: page
title: vUVu
user: mkovacs
project: vuvu
tagline: Visualize functions on the plane via GLSL.
---

# Description

vUVu visualizes functions on the plane (e.g.
[complex functions](https://en.wikipedia.org/wiki/Complex_analysis)) using GLSL.

It's written in C++.

# Usage

## Installation

vUVu depends on [OpenGL](https://en.wikipedia.org/wiki/OpenGL) and
[GLUT](https://en.wikipedia.org/wiki/OpenGL_Utility_Toolkit), so make sure you
have them.

To compile it, issue the following command from the main directory:
{% highlight bash %}
make
{% endhighlight %}

The included Makefile should work on most GNU/Linux distributions and on OSX.

## User Interface

The GLSL files describing the function are given as command-line arguments,
for example:
{% highlight bash %}
./vuvu util.fs example.fs
{% endhighlight %}

To reload the files on-the-fly, press R or F5.

You can drag the view around with the left mouse button, and zoom by dragging
vertically while holding the right mouse button.

## Examples

The following file describes the function:<br/>
f(x) := (x^2 - 1)\*(x + 2 - 2\*i)^2 / (x^2 + 2 + i)

{% highlight c %}
#version 120

vec3 complex2rgb(vec2 v); // defined in util.fs

vec2 conj(vec2 c) { return vec2(c.x, -c.y); }
vec2 mul(vec2 a, vec2 b) { return vec2(a.x*b.x - a.y*b.y, a.x*b.y + a.y*b.x); }
vec2 sqr(vec2 c) { return mul(c, c); }
vec2 div(vec2 a, vec2 b) { return mul(a, conj(b)) / dot(b, b); }

vec2 f(vec2 x)
{
  vec2 c_1 = vec2(1, 0);
  vec2 c_i = vec2(0, 1);
  return div( mul( sqr(x)-c_1, sqr(x + 2*c_1 - 2*c_i) ), sqr(x) + 2*c_1 + c_i );
}

void main(void)
{
  vec2 x = gl_TexCoord[0].xy;
  vec2 y = f(x);
  gl_FragColor.rgb = complex2rgb(y);
}
{% endhighlight %}

Most of the functions are needed to define complex arithmetic. You could use
[ReIm](http://mkovacs.github.com/reim), a complex number library for GLSL, so
you don't have to write these.

The function complex2rgb() is defined in util.fs, which contains routines for
converting a complex number to a color.

Here's a screenshot from its visualization:<br/>
![screenshot](pics/example-1.png)

Notice how the poles and zeros of the function are clearly visible.

# How it works

vUVu renders a full-screen quad with the U and V texture coordinates of its
corners set to the four corners of the view. The graphics hardware interpolates
these coordinates during rasterization, and runs the fragment shader (describing
the function and how to visualize its values) to compute the colors to display.
